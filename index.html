<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat (Cerebras + Pollinations helper)</title>

  <!-- Minimal styles to make UI usable -->
  <style>
    :root { --bg:#0b0b0b; --muted:#9ca3af; --panel:#111827; --accent:#10b981; }
    body { margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#e5e7eb; }
    .app { max-width:900px; margin:28px auto; padding:18px; }
    .chat { background:linear-gradient(180deg,#061021 0%,#071028 100%); border-radius:10px; padding:12px; min-height:380px; max-height:70vh; overflow:auto;}
    #messages-list { display:flex; flex-direction:column; gap:12px; }
    .msg-row { display:flex; }
    .msg-user { justify-content:flex-end; }
    .bubble-user { background:#1f2937; color:#fff; padding:8px 14px; border-radius:16px; max-width:75%; word-wrap:break-word; }
    .bubble-assistant { background:transparent; color:#e6eef8; padding:6px 0; max-width:100%; }
    .thought-wrapper { background:#0b1220; padding:8px; border-radius:8px; margin-bottom:6px; border-left:3px solid #334155; }
    .search-panel { background:#071029; border:1px solid rgba(255,255,255,0.04); padding:10px; border-radius:8px; margin-top:8px; }
    textarea { width:100%; min-height:80px; background:#061226; color:#e6eef8; border:1px solid rgba(255,255,255,0.04); padding:8px; border-radius:6px; resize:vertical; }
    .controls { display:flex; gap:8px; margin-top:10px; align-items:center; }
    .btn { background:#0ea5a4; color:#022; padding:8px 10px; border-radius:6px; cursor:pointer; border:none; }
    .btn.secondary { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); }
    .meta { color:var(--muted); font-size:13px; }
    form { display:flex; gap:8px; margin-top:12px; }
    input[type="text"] { flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:#071228; color:#e6eef8; }
  </style>

  <!-- Libraries: marked, DOMPurify, highlight.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
  <div class="app">
    <h2 style="margin:0 0 10px 0">Chat — Cerebras (Qwen) + Pollinations helper</h2>

    <div class="chat" id="chat-container" role="region" aria-label="Chat area">
      <div id="messages-list"></div>
      <div id="welcome-screen" style="display:flex; align-items:center; gap:12px; color:var(--muted); margin-top:12px;">
        <div class="meta">Welcome — ask something. If the assistant thinks it needs a web lookup you will see a search panel.</div>
      </div>
    </div>

    <form id="chat-form" aria-label="Chat form">
      <input id="user-input" type="text" placeholder="Message the assistant..." autocomplete="off" />
      <button id="send-btn" class="btn" type="submit">Send</button>
    </form>
  </div>

  <script>
  (function () {
    // --- Configuration (keep your key if you want) ---
    const API_KEY = 'csk-2mv8nxk4tpykc2hmhw4kywtpnp3hmtn5nc4fkn9y5y5jhrmp';
    const API_URL = 'https://api.cerebras.ai/v1/chat/completions';
    const POLLINATIONS_IMAGE_BASE = 'https://image.pollinations.ai/prompt/';

    // Minimal model list for selector compatibility
    const AVAILABLE_MODELS = [
      { id: 'qwen-3-235b-a22b-instruct-2507', name: 'Qwen 3 235B', description: 'Heavy duty instructions' },
      { id: 'sumo-ai-gen', name: 'SumoAiGenerator', description: 'Image generator' }
    ];
    let currentModelId = AVAILABLE_MODELS[0].id;

    // DOM references (script is at end, so OK)
    const chatContainer = document.getElementById('chat-container');
    const messagesList = document.getElementById('messages-list');
    const welcomeScreen = document.getElementById('welcome-screen');
    const chatForm = document.getElementById('chat-form');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');

    // Marked options & code highlight
    marked.setOptions({
      breaks: true,
      gfm: true
    });

    const SYSTEM_PROMPT_BASIC = "You are a helpful, expert coding assistant. Answer concisely and accurately.";
    const SYSTEM_PROMPT_THINKING = `You are a helpful, expert coding assistant.

CRITICAL INSTRUCTION:
To provide the highest quality answer, you MUST engage in a "Chain of Thought" reasoning process before answering.

If you determine that up-to-date or external information is required to answer the user correctly, inside the <think>...</think> block output exactly one search tag with the query you want performed and nothing else in that tag. Use either of these formats (prefer the first):

<search>your concise search query here</search>

or

[[SEARCH: your concise search query here]]

The front-end will detect this tag, present a small search panel and instructions (open a browser tab for the query and/or paste results). After search results are injected into the conversation, continue the reasoning and deliver the final answer.

FORMATTING RULES:
1. Start Immediately: Begin your response with <think>. No filler text.
2. Thinking Process: Inside <think>...</think>, Analyze, Plan, Critique.
   - If a web search is needed: output <search>query</search> (exactly as above) and stop producing the final answer until search results are provided.
3. Final Output: After closing </think>, provide the polished answer.
4. Keep the final answer concise unless asked for details.
`;

    let messages = [];

    // ========== Helpers ==========
    function detectSearchQuery(text) {
      if (!text) return null;
      const m1 = /<search>([\\s\\S]*?)<\\/search>/i.exec(text);
      if (m1) return m1[1].trim();
      const m2 = /\\[\\[SEARCH:\\s*([\\s\\S]*?)\\]\\]/i.exec(text);
      if (m2) return m2[1].trim();
      return null;
    }

    function appendMessage(role, content, isLoading = false) {
      if (messagesList.classList.contains('hidden')) {
        messagesList.classList.remove('hidden');
        welcomeScreen.style.display = 'none';
      }

      const row = document.createElement('div');
      row.className = 'msg-row ' + (role === 'user' ? 'msg-user' : 'msg-assistant');

      if (role === 'user') {
        const bubble = document.createElement('div');
        bubble.className = 'bubble-user';
        bubble.innerText = content;
        row.appendChild(bubble);
        messagesList.appendChild(row);
        scrollToBottom();
        return { row };
      } else {
        const container = document.createElement('div');
        container.className = 'bubble-assistant';
        const thinkingContainer = document.createElement('div');
        thinkingContainer.className = 'thought-wrapper';
        thinkingContainer.style.display = 'none';
        const answerContainer = document.createElement('div');
        answerContainer.className = 'answer-wrapper';
        if (isLoading) {
          answerContainer.innerHTML = '<div class="meta">Assistant is thinking...</div>';
        } else if (content) {
          answerContainer.innerHTML = DOMPurify.sanitize(marked.parse(content));
        }
        container.appendChild(thinkingContainer);
        container.appendChild(answerContainer);
        row.appendChild(container);
        messagesList.appendChild(row);
        scrollToBottom();
        return { row, thinkingContainer, answerContainer };
      }
    }

    function scrollToBottom() {
      chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
    }

    // Create search panel inside given container
    function createSearchPanel(container, query, onProvideResults) {
      const existing = container.querySelector('.search-panel');
      if (existing) return existing;

      const panel = document.createElement('div');
      panel.className = 'search-panel';
      panel.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="meta">Assistant requested a web lookup</div>
          <div class="meta">Query: <strong>${DOMPurify.sanitize(query)}</strong></div>
        </div>
        <div class="meta" style="margin-top:6px;">Open a search manually or use the auto Pollinations fetch (image) button.</div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button class="btn open-search secondary">Open Google</button>
          <button class="btn auto-poll">Auto fetch (Pollinations image)</button>
          <button class="btn fetch-proxy secondary">Attempt text fetch (proxy)</button>
        </div>
        <textarea placeholder="Paste top search result or summary here..." class="search-textarea"></textarea>
        <div style="display:flex; justify-content:flex-end; margin-top:8px;">
          <button class="btn provide-results">Provide results to AI</button>
        </div>
      `;

      const openBtn = panel.querySelector('.open-search');
      openBtn.addEventListener('click', () => {
        window.open('https://www.google.com/search?q=' + encodeURIComponent(query), '_blank');
      });

      panel.querySelector('.fetch-proxy').addEventListener('click', async () => {
        const ta = panel.querySelector('.search-textarea');
        ta.value = 'Fetching top result via r.jina.ai (may fail due to CORS)...';
        try {
          const proxyUrl = 'https://r.jina.ai/http://www.google.com/search?q=' + encodeURIComponent(query);
          const resp = await fetch(proxyUrl);
          const txt = await resp.text();
          ta.value = txt.slice(0, 4000);
        } catch (err) {
          ta.value = 'Automatic fetch failed (CORS/proxy). Please open the web search and paste results manually.';
        }
      });

      // Auto Pollinations fetch: create an image URL and insert it into textarea, then provide
      panel.querySelector('.auto-poll').addEventListener('click', async () => {
        const ta = panel.querySelector('.search-textarea');
        const imgUrl = POLLINATIONS_IMAGE_BASE + encodeURIComponent(query) + '?nologo=true';
        // Provide a simple text result containing the image URL plus an HTML image tag hint
        const value = `IMAGE FROM POLLINATIONS\n\nImage URL: ${imgUrl}\n\n(You can open the image link to view.)\n\n<!-- If desired, assistant can use this image link as part of reasoning. -->`;
        ta.value = value;
        // Small delay to let user see the value
        setTimeout(() => {
          onProvideResults(ta.value);
        }, 300);
      });

      panel.querySelector('.provide-results').addEventListener('click', () => {
        const ta = panel.querySelector('.search-textarea');
        const content = ta.value.trim();
        if (!content) { alert('Paste search results or use Auto fetch first.'); return; }
        onProvideResults(content);
      });

      container.appendChild(panel);
      return panel;
    }

    // Reset chat
    function resetChat() {
      messages = [{ role: "system", content: SYSTEM_PROMPT_THINKING }];
      messagesList.innerHTML = '';
      welcomeScreen.style.display = 'flex';
      userInput.value = '';
    }

    // --- Streaming + search-aware flow ---
    async function sendMessagesToApi() {
      // render placeholder assistant message
      const aiMsgEls = appendMessage('assistant', '', true);
      scrollToBottom();

      let fullResponse = "";

      try {
        const apiMessages = messages.map(m => ({ ...m }));

        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_KEY}`
          },
          body: JSON.stringify({
            model: currentModelId,
            messages: apiMessages,
            stream: true,
            temperature: 0.2,
            max_tokens: 2000
          })
        });

        if (!resp.ok) {
          const text = await resp.text().catch(()=>'');
          throw new Error('API Error: ' + resp.status + ' ' + text);
        }

        // Replace loading UI
        if (aiMsgEls.answerContainer) aiMsgEls.answerContainer.innerHTML = '';

        const reader = resp.body.getReader();
        const decoder = new TextDecoder('utf-8');

        // We'll read stream chunks and update UI progressively
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (!line) continue;
            // Many stream implementations prefix "data: "
            const payload = line.startsWith('data: ') ? line.substring(6) : line;
            if (payload === '[DONE]') continue;
            try {
              const json = JSON.parse(payload);
              const content = json.choices?.[0]?.delta?.content || '';
              fullResponse += content;

              // detect <think> ... </think>
              const thinkStartMatch = /<think>/i.exec(fullResponse);
              const thinkEndMatch = /<\/think>/i.exec(fullResponse);
              const thinkStart = thinkStartMatch ? thinkStartMatch.index : -1;
              const thinkEnd = thinkEndMatch ? thinkEndMatch.index : -1;

              let thoughtPart = "";
              let answerPart = fullResponse;
              let isThinking = false;

              if (thinkStart !== -1) {
                if (thinkEnd !== -1) {
                  thoughtPart = fullResponse.substring(thinkStart + 7, thinkEnd);
                  const postThink = fullResponse.substring(thinkEnd + 8);
                  answerPart = postThink;
                } else {
                  thoughtPart = fullResponse.substring(thinkStart + 7);
                  answerPart = "";
                  isThinking = true;
                }
              }

              if (thoughtPart) {
                aiMsgEls.thinkingContainer.style.display = '';
                const query = detectSearchQuery(thoughtPart);
                // Show thought as parsed markdown
                aiMsgEls.thinkingContainer.innerHTML = DOMPurify.sanitize(marked.parse(thoughtPart));

                if (query) {
                  // Create search UI and let user provide results or auto-fetch via Pollinations
                  createSearchPanel(aiMsgEls.thinkingContainer, query, (searchResults) => {
                    // When user (or auto) provides results, inject them as a user message and re-run the API
                    messages.push({ role: 'user', content: `SEARCH RESULTS for: "${query}"\n\n${searchResults}` });
                    // Start another request cycle — assistant should pick up search results
                    // Important: call sendMessagesToApi but don't await to avoid blocking UI here
                    // We still finish current reader loop; the assistant will emit final output after the new call too.
                    setTimeout(() => sendMessagesToApi(), 20);
                  });
                }
              }

              if (answerPart) {
                aiMsgEls.answerContainer.innerHTML = DOMPurify.sanitize(marked.parse(answerPart));
                // syntax highlight after injecting code blocks
                aiMsgEls.answerContainer.querySelectorAll('pre code').forEach((block) => {
                  hljs.highlightElement(block);
                });
              } else if (isThinking) {
                aiMsgEls.answerContainer.innerHTML = '';
              }

              scrollToBottom();
            } catch (err) {
              // not JSON — ignore
            }
          }
        } // end reading loop

        // push assistant message to history
        messages.push({ role: "assistant", content: fullResponse });

      } catch (err) {
        console.error('sendMessagesToApi error', err);
        if (aiMsgEls && aiMsgEls.answerContainer) {
          aiMsgEls.answerContainer.innerHTML = `<div class="meta" style="color:#f87171">Error connecting to AI: ${err.message}</div>`;
        }
      }
    }

    // Form submit handler
    chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = userInput.value.trim();
      if (!text) return;

      appendMessage('user', text);
      messages.push({ role: "user", content: text });

      userInput.value = '';
      scrollToBottom();

      // If image generator model requested (sumo-ai-gen) use Pollinations to generate image and return
      if (currentModelId === 'sumo-ai-gen') {
        const aiEls = appendMessage('assistant', '', true);
        const prompt = text;
        const imgUrl = POLLINATIONS_IMAGE_BASE + encodeURIComponent(prompt) + '?nologo=true';
        const responseText = `**Generated Image** for: _${prompt}_\n\n![${prompt}](${imgUrl})\n\nImage URL: ${imgUrl}`;
        aiEls.answerContainer.innerHTML = DOMPurify.sanitize(marked.parse(responseText));
        messages.push({ role: "assistant", content: responseText });
        scrollToBottom();
        return;
      }

      // Standard: send to Cerebras streaming endpoint
      await sendMessagesToApi();
    });

    // initialization
    resetChat();
  })();
  </script>
</body>
</html>
